{
  "BasedOnStyle": {
    "type": "string",
    "doc": "<p>  The style used for all options not specifically set in the configuration.</p>\n<p>  This option is supported only in the <strong>clang-format</strong> configuration\n  (both within <code>-style=&#39;{...}&#39;</code> and the <code>.clang-format</code> file).</p>\n<p>  Possible values:</p>\n<ul>\n<li><code>LLVM</code>\nA style complying with the <a href=\"http://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></li>\n<li><code>Google</code>\nA style complying with <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\">Google&#39;s C++ style guide</a></li>\n<li><code>Chromium</code>\nA style complying with <a href=\"http://www.chromium.org/developers/coding-style\">Chromium&#39;s style guide</a></li>\n<li><code>Mozilla</code>\nA style complying with <a href=\"https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style\">Mozilla&#39;s style guide</a></li>\n<li><code>WebKit</code>\nA style complying with <a href=\"http://www.webkit.org/coding/coding-style.html\">WebKit&#39;s style guide</a></li>\n</ul>\n",
    "options": [
      "LLVM",
      "Google",
      "Chromium",
      "Mozilla",
      "WebKit"
    ]
  },
  "AccessModifierOffset": {
    "type": "int",
    "doc": "<p>  The extra indent or outdent of access modifiers, e.g. <code>public:</code>.</p>\n"
  },
  "AlignAfterOpenBracket": {
    "type": "BracketAlignmentStyle",
    "doc": "<p>  If <code>true</code>, horizontally aligns arguments after an open bracket.</p>\n<p>  This applies to round brackets (parentheses), angle brackets and square\n  brackets.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BAS_Align</code> (in configuration: <code>Align</code>)\nAlign parameters on the open bracket, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n                   argument2);\n</code></pre></li>\n<li><p><code>BAS_DontAlign</code> (in configuration: <code>DontAlign</code>)\nDon&#39;t align, instead use <code>ContinuationIndentWidth</code>, e.g.:</p>\n<pre><code>  someLongFunction(argument1,\n      argument2);\n</code></pre></li>\n<li><p><code>BAS_AlwaysBreak</code> (in configuration: <code>AlwaysBreak</code>)\nAlways break after an open bracket, if the parameters don&#39;t fit\non a single line, e.g.:</p>\n<pre><code>  someLongFunction(\n      argument1, argument2);\n</code></pre></li>\n</ul>\n",
    "options": [
      "Align",
      "DontAlign",
      "AlwaysBreak"
    ]
  },
  "AlignConsecutiveAssignments": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, aligns consecutive assignments.</p>\n<p>  This will align the assignment operators of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int aaaa = 12;\n    int b    = 23;\n    int ccc  = 23;\n</code></pre>\n"
  },
  "AlignConsecutiveDeclarations": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, aligns consecutive declarations.</p>\n<p>  This will align the declaration names of consecutive lines. This\n  will result in formattings like</p>\n<pre><code class=\"lang-  \">    int         aaaa = 12;\n    float       b = 23;\n    std::string ccc = 23;\n</code></pre>\n"
  },
  "AlignEscapedNewlinesLeft": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, aligns escaped newlines as far left as possible.\n  Otherwise puts them into the right-most column.</p>\n"
  },
  "AlignOperands": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, horizontally align operands of binary and ternary\n  expressions.</p>\n<p>  Specifically, this aligns operands of a single expression that needs to be\n  split over multiple lines, e.g.:</p>\n<pre><code class=\"lang-  \">    int aaa = bbbbbbbbbbbbbbb +\n              ccccccccccccccc;\n</code></pre>\n"
  },
  "AlignTrailingComments": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, aligns trailing comments.</p>\n"
  },
  "AllowAllParametersOfDeclarationOnNextLine": {
    "type": "bool",
    "doc": "<p>  Allow putting all parameters of a function declaration onto\n  the next line even if <code>BinPackParameters</code> is <code>false</code>.</p>\n"
  },
  "AllowShortBlocksOnASingleLine": {
    "type": "bool",
    "doc": "<p>  Allows contracting simple braced statements to a single line.</p>\n<p>  E.g., this allows <code>if (a) { return; }</code> to be put on a single line.</p>\n"
  },
  "AllowShortCaseLabelsOnASingleLine": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, short case labels will be contracted to a single line.</p>\n"
  },
  "AllowShortFunctionsOnASingleLine": {
    "type": "ShortFunctionStyle",
    "doc": "<p>  Dependent on the value, <code>int f() { return 0; }</code> can be put on a\n  single line.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SFS_None</code> (in configuration: <code>None</code>)\nNever merge functions into a single line.</p>\n</li>\n<li><p><code>SFS_Empty</code> (in configuration: <code>Empty</code>)\nOnly merge empty functions.</p>\n</li>\n<li><p><code>SFS_Inline</code> (in configuration: <code>Inline</code>)\nOnly merge functions defined inside a class. Implies &quot;empty&quot;.</p>\n</li>\n<li><p><code>SFS_All</code> (in configuration: <code>All</code>)\nMerge all functions fitting on a single line.</p>\n</li>\n</ul>\n",
    "options": [
      "None",
      "Empty",
      "Inline",
      "All"
    ]
  },
  "AllowShortIfStatementsOnASingleLine": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, <code>if (a) return;</code> can be put on a single line.</p>\n"
  },
  "AllowShortLoopsOnASingleLine": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, <code>while (true) continue;</code> can be put on a single\n  line.</p>\n"
  },
  "AlwaysBreakAfterDefinitionReturnType": {
    "type": "DefinitionReturnTypeBreakingStyle",
    "doc": "<p>  The function definition return type breaking style to use.  This\n  option is deprecated and is retained for backwards compatibility.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>DRTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n</li>\n<li><p><code>DRTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n</li>\n<li><p><code>DRTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n</li>\n</ul>\n",
    "options": [
      "None",
      "All",
      "TopLevel"
    ]
  },
  "AlwaysBreakAfterReturnType": {
    "type": "ReturnTypeBreakingStyle",
    "doc": "<p>  The function declaration return type breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>RTBS_None</code> (in configuration: <code>None</code>)\nBreak after return type automatically.\n<code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account.</p>\n</li>\n<li><p><code>RTBS_All</code> (in configuration: <code>All</code>)\nAlways break after the return type.</p>\n</li>\n<li><p><code>RTBS_TopLevel</code> (in configuration: <code>TopLevel</code>)\nAlways break after the return types of top-level functions.</p>\n</li>\n<li><p><code>RTBS_AllDefinitions</code> (in configuration: <code>AllDefinitions</code>)\nAlways break after the return type of function definitions.</p>\n</li>\n<li><p><code>RTBS_TopLevelDefinitions</code> (in configuration: <code>TopLevelDefinitions</code>)\nAlways break after the return type of top-level definitions.</p>\n</li>\n</ul>\n",
    "options": [
      "None",
      "All",
      "TopLevel",
      "AllDefinitions",
      "TopLevelDefinitions"
    ]
  },
  "AlwaysBreakBeforeMultilineStrings": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, always break before multiline string literals.</p>\n<p>  This flag is mean to make cases where there are multiple multiline strings\n  in a file look more consistent. Thus, it will only take effect if wrapping\n  the string at that point leads to it being indented\n  <code>ContinuationIndentWidth</code> spaces from the start of the line.</p>\n"
  },
  "AlwaysBreakTemplateDeclarations": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, always break after the <code>template&lt;...&gt;</code> of a template\n  declaration.</p>\n"
  },
  "BinPackArguments": {
    "type": "bool",
    "doc": "<p>  If <code>false</code>, a function call&#39;s arguments will either be all on the\n  same line or will have one line each.</p>\n"
  },
  "BinPackParameters": {
    "type": "bool",
    "doc": "<p>  If <code>false</code>, a function declaration&#39;s or function definition&#39;s\n  parameters will either all be on the same line or will have one line each.</p>\n"
  },
  "BraceWrapping": {
    "type": "BraceWrappingFlags",
    "doc": "<p>  Control of individual brace wrapping cases.</p>\n<p>  If <code>BreakBeforeBraces</code> is set to <code>BS_Custom</code>, use this to specify how\n  each individual brace case should be handled. Otherwise, this is ignored.</p>\n<p>  Nested configuration flags:</p>\n<ul>\n<li><code>bool AfterClass</code> Wrap class definitions.</li>\n<li><code>bool AfterControlStatement</code> Wrap control statements (<code>if</code>/<code>for</code>/<code>while</code>/<code>switch</code>/..).</li>\n<li><code>bool AfterEnum</code> Wrap enum definitions.</li>\n<li><code>bool AfterFunction</code> Wrap function definitions.</li>\n<li><code>bool AfterNamespace</code> Wrap namespace definitions.</li>\n<li><code>bool AfterObjCDeclaration</code> Wrap ObjC definitions (<code>@autoreleasepool</code>, interfaces, ..).</li>\n<li><code>bool AfterStruct</code> Wrap struct definitions.</li>\n<li><code>bool AfterUnion</code> Wrap union definitions.</li>\n<li><code>bool BeforeCatch</code> Wrap before <code>catch</code>.</li>\n<li><code>bool BeforeElse</code> Wrap before <code>else</code>.</li>\n<li><code>bool IndentBraces</code> Indent the wrapped braces themselves.</li>\n</ul>\n",
    "options": []
  },
  "BreakAfterJavaFieldAnnotations": {
    "type": "bool",
    "doc": "<p>  Break after each annotation on a field in Java files.</p>\n"
  },
  "BreakBeforeBinaryOperators": {
    "type": "BinaryOperatorStyle",
    "doc": "<p>  The way to wrap binary operators.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BOS_None</code> (in configuration: <code>None</code>)\nBreak after operators.</p>\n</li>\n<li><p><code>BOS_NonAssignment</code> (in configuration: <code>NonAssignment</code>)\nBreak before operators that aren&#39;t assignments.</p>\n</li>\n<li><p><code>BOS_All</code> (in configuration: <code>All</code>)\nBreak before operators.</p>\n</li>\n</ul>\n",
    "options": [
      "None",
      "NonAssignment",
      "All"
    ]
  },
  "BreakBeforeBraces": {
    "type": "BraceBreakingStyle",
    "doc": "<p>  The brace breaking style to use.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>BS_Attach</code> (in configuration: <code>Attach</code>)\nAlways attach braces to surrounding context.</p>\n</li>\n<li><p><code>BS_Linux</code> (in configuration: <code>Linux</code>)\nLike <code>Attach</code>, but break before braces on function, namespace and\nclass definitions.</p>\n</li>\n<li><p><code>BS_Mozilla</code> (in configuration: <code>Mozilla</code>)\nLike <code>Attach</code>, but break before braces on enum, function, and record\ndefinitions.</p>\n</li>\n<li><p><code>BS_Stroustrup</code> (in configuration: <code>Stroustrup</code>)\nLike <code>Attach</code>, but break before function definitions, <code>catch</code>, and\n<code>else</code>.</p>\n</li>\n<li><p><code>BS_Allman</code> (in configuration: <code>Allman</code>)\nAlways break before braces.</p>\n</li>\n<li><p><code>BS_GNU</code> (in configuration: <code>GNU</code>)\nAlways break before braces and add an extra level of indentation to\nbraces of control statements, not to those of class, function\nor other definitions.</p>\n</li>\n<li><p><code>BS_WebKit</code> (in configuration: <code>WebKit</code>)\nLike <code>Attach</code>, but break before functions.</p>\n</li>\n<li><p><code>BS_Custom</code> (in configuration: <code>Custom</code>)\nConfigure each individual brace in `BraceWrapping`.</p>\n</li>\n</ul>\n",
    "options": [
      "Attach",
      "Linux",
      "Mozilla",
      "Stroustrup",
      "Allman",
      "GNU",
      "WebKit",
      "Custom"
    ]
  },
  "BreakBeforeTernaryOperators": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, ternary operators will be placed after line breaks.</p>\n"
  },
  "BreakConstructorInitializersBeforeComma": {
    "type": "bool",
    "doc": "<p>  Always break constructor initializers before commas and align\n  the commas with the colon.</p>\n"
  },
  "BreakStringLiterals": {
    "type": "bool",
    "doc": "<p>  Allow breaking string literals when formatting.</p>\n"
  },
  "ColumnLimit": {
    "type": "unsigned",
    "doc": "<p>  The column limit.</p>\n<p>  A column limit of <code>0</code> means that there is no column limit. In this case,\n  clang-format will respect the input&#39;s line breaking decisions within\n  statements unless they contradict other rules.</p>\n"
  },
  "CommentPragmas": {
    "type": "std::string",
    "doc": "<p>  A regular expression that describes comments with special meaning,\n  which should not be split into lines or otherwise changed.</p>\n"
  },
  "ConstructorInitializerAllOnOneLineOrOnePerLine": {
    "type": "bool",
    "doc": "<p>  If the constructor initializers don&#39;t fit on a line, put each\n  initializer on its own line.</p>\n"
  },
  "ConstructorInitializerIndentWidth": {
    "type": "unsigned",
    "doc": "<p>  The number of characters to use for indentation of constructor\n  initializer lists.</p>\n"
  },
  "ContinuationIndentWidth": {
    "type": "unsigned",
    "doc": "<p>  Indent width for line continuations.</p>\n"
  },
  "Cpp11BracedListStyle": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, format braced lists as best suited for C++11 braced\n  lists.</p>\n<p>  Important differences:</p>\n<ul>\n<li>No spaces inside the braced list.</li>\n<li>No line break before the closing brace.</li>\n<li><p>Indentation with the continuation indent, not with the block indent.</p>\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the <code>{}</code> were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.</p>\n</li>\n</ul>\n"
  },
  "DerivePointerAlignment": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, analyze the formatted file for the most common\n  alignment of <code>&amp;</code> and <code>\\*</code>. <code>PointerAlignment</code> is then used only as\n  fallback.</p>\n"
  },
  "DisableFormat": {
    "type": "bool",
    "doc": "<p>  Disables formatting completely.</p>\n"
  },
  "ExperimentalAutoDetectBinPacking": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, clang-format detects whether function calls and\n  definitions are formatted with one parameter per line.</p>\n<p>  Each call can be bin-packed, one-per-line or inconclusive. If it is\n  inconclusive, e.g. completely on one line, but a decision needs to be\n  made, clang-format analyzes whether there are other bin-packed cases in\n  the input file and act accordingly.</p>\n<p>  NOTE: This is an experimental flag, that might go away or be renamed. Do\n  not use this in config files, etc. Use at your own risk.</p>\n"
  },
  "ForEachMacros": {
    "type": "std::vector<std::string>",
    "doc": "<p>  A vector of macros that should be interpreted as foreach loops\n  instead of as function calls.</p>\n<p>  These are expected to be macros of the form:</p>\n<pre><code class=\"lang-  \">    FOREACH(&lt;variable-declaration&gt;, ...)\n      &lt;loop-body&gt;\n</code></pre>\n<p>  In the .clang-format configuration file, this can be configured like:</p>\n<pre><code class=\"lang-  \">    ForEachMacros: [&#39;RANGES_FOR&#39;, &#39;FOREACH&#39;]\n</code></pre>\n<p>  For example: BOOST_FOREACH.</p>\n"
  },
  "IncludeCategories": {
    "type": "std::vector<IncludeCategory>",
    "doc": "<p>  Regular expressions denoting the different <code>#include</code> categories\n  used for ordering <code>#includes</code>.</p>\n<p>  These regular expressions are matched against the filename of an include\n  (including the &lt;&gt; or &quot;&quot;) in order. The value belonging to the first\n  matching regular expression is assigned and <code>#includes</code> are sorted first\n  according to increasing category number and then alphabetically within\n  each category.</p>\n<p>  If none of the regular expressions match, INT_MAX is assigned as\n  category. The main header for a source file automatically gets category 0.\n  so that it is generally kept at the beginning of the <code>#includes</code>\n  (http://llvm.org/docs/CodingStandards.html#include-style). However, you\n  can also assign negative priorities if you have certain headers that\n  always need to be first.</p>\n<p>  To configure this in the .clang-format file, use:</p>\n<pre><code class=\"lang-  \">    IncludeCategories:\n      - Regex:           &#39;^&quot;(llvm|llvm-c|clang|clang-c)/&#39;\n        Priority:        2\n      - Regex:           &#39;^(&lt;|&quot;(gtest|isl|json)/)&#39;\n        Priority:        3\n      - Regex:           &#39;.\\*&#39;\n        Priority:        1\n</code></pre>\n",
    "options": []
  },
  "IncludeIsMainRegex": {
    "type": "std::string",
    "doc": "<p>  Specify a regular expression of suffixes that are allowed in the\n  file-to-main-include mapping.</p>\n<p>  When guessing whether a #include is the &quot;main&quot; include (to assign\n  category 0, see above), use this regex of allowed suffixes to the header\n  stem. A partial match is done, so that:</p>\n<ul>\n<li>&quot;&quot; means &quot;arbitrary suffix&quot;</li>\n<li><p>&quot;$&quot; means &quot;no suffix&quot;</p>\n<p>For example, if configured to &quot;(_test)?$&quot;, then a header a.h would be seen\nas the &quot;main&quot; include in both a.cc and a_test.cc.</p>\n</li>\n</ul>\n"
  },
  "IndentCaseLabels": {
    "type": "bool",
    "doc": "<p>  Indent case labels one level from the switch statement.</p>\n<p>  When <code>false</code>, use the same indentation level as for the switch statement.\n  Switch statement body is always indented one level more than case labels.</p>\n"
  },
  "IndentWidth": {
    "type": "unsigned",
    "doc": "<p>  The number of columns to use for indentation.</p>\n"
  },
  "IndentWrappedFunctionNames": {
    "type": "bool",
    "doc": "<p>  Indent if a function definition or declaration is wrapped after the\n  type.</p>\n"
  },
  "JavaScriptQuotes": {
    "type": "JavaScriptQuoteStyle",
    "doc": "<p>  The JavaScriptQuoteStyle to use for JavaScript strings.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>JSQS_Leave</code> (in configuration: <code>Leave</code>)\nLeave string quotes as they are.</p>\n</li>\n<li><p><code>JSQS_Single</code> (in configuration: <code>Single</code>)\nAlways use single quotes.</p>\n</li>\n<li><p><code>JSQS_Double</code> (in configuration: <code>Double</code>)\nAlways use double quotes.</p>\n</li>\n</ul>\n",
    "options": [
      "Leave",
      "Single",
      "Double"
    ]
  },
  "KeepEmptyLinesAtTheStartOfBlocks": {
    "type": "bool",
    "doc": "<p>  If true, empty lines at the start of blocks are kept.</p>\n"
  },
  "Language": {
    "type": "LanguageKind",
    "doc": "<p>  Language, this format style is targeted at.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LK_None</code> (in configuration: <code>None</code>)\nDo not use.</p>\n</li>\n<li><p><code>LK_Cpp</code> (in configuration: <code>Cpp</code>)\nShould be used for C, C++, ObjectiveC, ObjectiveC++.</p>\n</li>\n<li><p><code>LK_Java</code> (in configuration: <code>Java</code>)\nShould be used for Java.</p>\n</li>\n<li><p><code>LK_JavaScript</code> (in configuration: <code>JavaScript</code>)\nShould be used for JavaScript.</p>\n</li>\n<li><p><code>LK_Proto</code> (in configuration: <code>Proto</code>)\nShould be used for Protocol Buffers\n(https://developers.google.com/protocol-buffers/).</p>\n</li>\n<li><p><code>LK_TableGen</code> (in configuration: <code>TableGen</code>)\nShould be used for TableGen code.</p>\n</li>\n</ul>\n",
    "options": [
      "None",
      "Cpp",
      "Java",
      "JavaScript",
      "Proto",
      "TableGen"
    ]
  },
  "MacroBlockBegin": {
    "type": "std::string",
    "doc": "<p>  A regular expression matching macros that start a block.</p>\n"
  },
  "MacroBlockEnd": {
    "type": "std::string",
    "doc": "<p>  A regular expression matching macros that end a block.</p>\n"
  },
  "MaxEmptyLinesToKeep": {
    "type": "unsigned",
    "doc": "<p>  The maximum number of consecutive empty lines to keep.</p>\n"
  },
  "NamespaceIndentation": {
    "type": "NamespaceIndentationKind",
    "doc": "<p>  The indentation used for namespaces.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>NI_None</code> (in configuration: <code>None</code>)\nDon&#39;t indent in namespaces.</p>\n</li>\n<li><p><code>NI_Inner</code> (in configuration: <code>Inner</code>)\nIndent only in inner namespaces (nested in other namespaces).</p>\n</li>\n<li><p><code>NI_All</code> (in configuration: <code>All</code>)\nIndent in all namespaces.</p>\n</li>\n</ul>\n",
    "options": [
      "None",
      "Inner",
      "All"
    ]
  },
  "ObjCBlockIndentWidth": {
    "type": "unsigned",
    "doc": "<p>  The number of characters to use for indentation of ObjC blocks.</p>\n"
  },
  "ObjCSpaceAfterProperty": {
    "type": "bool",
    "doc": "<p>  Add a space after <code>@property</code> in Objective-C, i.e. use\n  <code>@property (readonly)</code> instead of <code>@property(readonly)</code>.</p>\n"
  },
  "ObjCSpaceBeforeProtocolList": {
    "type": "bool",
    "doc": "<p>  Add a space in front of an Objective-C protocol list, i.e. use\n  <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>.</p>\n"
  },
  "PenaltyBreakBeforeFirstCallParameter": {
    "type": "unsigned",
    "doc": "<p>  The penalty for breaking a function call after <code>call(</code>.</p>\n"
  },
  "PenaltyBreakComment": {
    "type": "unsigned",
    "doc": "<p>  The penalty for each line break introduced inside a comment.</p>\n"
  },
  "PenaltyBreakFirstLessLess": {
    "type": "unsigned",
    "doc": "<p>  The penalty for breaking before the first <code>&lt;&lt;</code>.</p>\n"
  },
  "PenaltyBreakString": {
    "type": "unsigned",
    "doc": "<p>  The penalty for each line break introduced inside a string literal.</p>\n"
  },
  "PenaltyExcessCharacter": {
    "type": "unsigned",
    "doc": "<p>  The penalty for each character outside of the column limit.</p>\n"
  },
  "PenaltyReturnTypeOnItsOwnLine": {
    "type": "unsigned",
    "doc": "<p>  Penalty for putting the return type of a function onto its own\n  line.</p>\n"
  },
  "PointerAlignment": {
    "type": "PointerAlignmentStyle",
    "doc": "<p>  Pointer and reference alignment style.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>PAS_Left</code> (in configuration: <code>Left</code>)\nAlign pointer to the left.</p>\n</li>\n<li><p><code>PAS_Right</code> (in configuration: <code>Right</code>)\nAlign pointer to the right.</p>\n</li>\n<li><p><code>PAS_Middle</code> (in configuration: <code>Middle</code>)\nAlign pointer in the middle.</p>\n</li>\n</ul>\n",
    "options": [
      "Left",
      "Right",
      "Middle"
    ]
  },
  "ReflowComments": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, clang-format will attempt to re-flow comments.</p>\n"
  },
  "SortIncludes": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, clang-format will sort <code>#includes</code>.</p>\n"
  },
  "SpaceAfterCStyleCast": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, a space may be inserted after C style casts.</p>\n"
  },
  "SpaceBeforeAssignmentOperators": {
    "type": "bool",
    "doc": "<p>  If <code>false</code>, spaces will be removed before assignment operators.</p>\n"
  },
  "SpaceBeforeParens": {
    "type": "SpaceBeforeParensOptions",
    "doc": "<p>  Defines in which cases to put a space before opening parentheses.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>SBPO_Never</code> (in configuration: <code>Never</code>)\nNever put a space before opening parentheses.</p>\n</li>\n<li><p><code>SBPO_ControlStatements</code> (in configuration: <code>ControlStatements</code>)\nPut a space before opening parentheses only after control statement\nkeywords (<code>for/if/while...</code>).</p>\n</li>\n<li><p><code>SBPO_Always</code> (in configuration: <code>Always</code>)\nAlways put a space before opening parentheses, except when it&#39;s\nprohibited by the syntax rules (in function-like macro definitions) or\nwhen determined by other style rules (after unary operators, opening\nparentheses, etc.)</p>\n</li>\n</ul>\n",
    "options": [
      "Never",
      "ControlStatements",
      "Always"
    ]
  },
  "SpaceInEmptyParentheses": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, spaces may be inserted into <code>()</code>.</p>\n"
  },
  "SpacesBeforeTrailingComments": {
    "type": "unsigned",
    "doc": "<p>  The number of spaces before trailing line comments\n  (<code>//</code> - comments).</p>\n<p>  This does not affect trailing block comments (<code>/*</code> - comments) as\n  those commonly have different usage patterns and a number of special\n  cases.</p>\n"
  },
  "SpacesInAngles": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>&lt;</code> and before <code>&gt;</code>\n  in template argument lists.</p>\n"
  },
  "SpacesInCStyleCastParentheses": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, spaces may be inserted into C style casts.</p>\n"
  },
  "SpacesInContainerLiterals": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, spaces are inserted inside container literals (e.g.\n  ObjC and Javascript array and dict literals).</p>\n"
  },
  "SpacesInParentheses": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>(</code> and before <code>)</code>.</p>\n"
  },
  "SpacesInSquareBrackets": {
    "type": "bool",
    "doc": "<p>  If <code>true</code>, spaces will be inserted after <code>[</code> and before <code>]</code>.</p>\n"
  },
  "Standard": {
    "type": "LanguageStandard",
    "doc": "<p>  Format compatible with this standard, e.g. use <code>A&lt;A&lt;int&gt; &gt;</code>\n  instead of <code>A&lt;A&lt;int&gt;&gt;</code> for <code>LS_Cpp03</code>.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>LS_Cpp03</code> (in configuration: <code>Cpp03</code>)\nUse C++03-compatible syntax.</p>\n</li>\n<li><p><code>LS_Cpp11</code> (in configuration: <code>Cpp11</code>)\nUse features of C++11 (e.g. <code>A&lt;A&lt;int&gt;&gt;</code> instead of <code>A&lt;A&lt;int&gt; &gt;</code>).</p>\n</li>\n<li><p><code>LS_Auto</code> (in configuration: <code>Auto</code>)\nAutomatic detection based on the input.</p>\n</li>\n</ul>\n",
    "options": [
      "Cpp03",
      "Cpp11",
      "Auto"
    ]
  },
  "TabWidth": {
    "type": "unsigned",
    "doc": "<p>  The number of columns used for tab stops.</p>\n"
  },
  "UseTab": {
    "type": "UseTabStyle",
    "doc": "<p>  The way to use tab characters in the resulting file.</p>\n<p>  Possible values:</p>\n<ul>\n<li><p><code>UT_Never</code> (in configuration: <code>Never</code>)\nNever use tab.</p>\n</li>\n<li><p><code>UT_ForIndentation</code> (in configuration: <code>ForIndentation</code>)\nUse tabs only for indentation.</p>\n</li>\n<li><p><code>UT_Always</code> (in configuration: <code>Always</code>)\nUse tabs whenever we need to fill whitespace that spans at least from\none tab stop to the next one.</p>\n</li>\n</ul>\n",
    "options": [
      "Never",
      "ForIndentation",
      "Always"
    ]
  }
}
